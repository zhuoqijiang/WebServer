# WebServer

## 简介

由 C++ 编写的网络库，代码量在 1800 行左右。

## 环境

`Linux version 4.15.0-118-generic (buildd@lgw01-amd64-039) (gcc version 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)) `

## 使用

- 下载 `cmake, make, g++`
- 在当前目录（即 `CMakeLists.txt` 所在目录）执行 `cmake .`
- 成功后，执行 `make` ，可得到一个可执行文件 `WebServer`
- 执行 `./WebServer -t [threadNum] -p port -l [logPath]` 或使用默认参数的 `.WebServer`
- 需要加入的 `.html` 文件请放在目录 `html` 中，目前仅支持 `GET` 模式

## 实现

### 工作流程

1. 主线程解析命令行参数（子线程开启个数（默认为 `1`），指定端口（默认为 `80`），指定文件输出路径（默认当前位置 `log.txt`））
2. 主线程负责监听端口，当全连接队列有事件到达时（三次握手完成)，会唤醒主线程以边缘触发非阻塞的方式对事件进行 `accept`，对得到的文件描述符分配 `HttpData`，并以轮询的方式分配给子线程（尽量达到负载均衡）
3. 子线程得到主线程分配的 `HttpData` 之后，将其添加到本线程的 `epoll` 当中，当有事件可读时，系统对子线程进行唤醒，子线程对事件进行读取，解析读取的数据，如果数据的格式是正确的，会将解析后的数据写入缓冲区，如果一次性没将数据写入（如写缓冲区满），会注册事件的写事件，以顺利将数据写入写缓冲区。
4. 子线程和主线程都有注册定时器，主线程的定时器关注的是将旧日志数据队列加入到主日志数据队列（双队列缓冲），子线程的定时器关注的是连接对象的连接时间，定时将过期连接对象进行清除。 定时器默认每5秒唤醒一次

### 日志系统

- 日志的等级有 4 个等级，分别为 `DEBUG, INFO, WARN, ERROR`，日志可以选择向控制台和文件进行输出，（日志内容包含所在函数，行数，时间，时间戳，内容等）
- 由于对文件的读写涉及到磁盘，而对磁盘的操作速度是远小于内存的，所以采用异步的方式对日志进行写入，日志开启时会开启一个线程池（只开启一个线程），每 append 一条日志，其实是将日志的格式 `LogEvent` 添加到线程池二级缓冲队列，当二级缓冲队列收集到 100 个 `LogEvent` 时会将此队列加入到一级队列当中，此时会唤醒线程池的线程对其进行读写，二级缓冲队列的目的是防止频繁的唤醒线程池里的线程。但是这样会导致未满 100 个 `LogEvent` 的队列里的数据无法写入磁盘，所以主线程会定时的将二级缓冲队列的内容加入一级缓冲队列

### 网络结构

1. `Epoll`：Linux 上主要的 IO 多路复用方式有 `select, poll, epoll`，而 `epoll` 的平均效率是最高的，所以采用 `epoll` 的方式来对事件进行监听从而实现一个线程能同时监听多个对象
2. `Channel`：`Acceptor，HttpData，TimerQueue` 的结构会注册 `Channel` 的 `readcallback, closecallback`
3. `EventLoop`：整个框架的核心，由于框架采用 one loop per thread 的思想，所以每个线程都有一个 `Eventloop `结构，`Eventloo`  控制着一个线程的所有活动，每当poll有事件返回时，loop 都会唤醒执行 `channel` 的 `handleEvent` 函数，由于程序一直运行着所以结构中的函数 `loop` 是个死循环

## 不足

1.  时间戳精确度都是以秒为单位的，精确度不足够 
2.  日志系统没有对日志输出对象大小进行监控，所以需要定期检查日志输出对象的大小，防止过大 
3.  测压的时候随着并发量和反问量的变高，响应的失败率会变高很多 
4.  目前只支持 `GET` 请求类型 